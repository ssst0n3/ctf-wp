# [SSCTF 2016](http://lab.seclover.com/about) : HeHeDa

it's not write by me. author:tothi https://github.com/tothi/ctfs/blob/master/ssctf-2016/crypto-exploit/heheda-100/README.md

**Category:** Crypto-Exploit
**Points:** 100
**Solves:** 183
**Description:**

> 该题目已有 183 个队伍完成
>
> It has completed by 183 teams
>
> 解题说明
>
> Description
>
>
> Crack Algorithm~
>
> 战题链接 <http://static.lab.seclover.com/crypto/Algorithm1-577265e1.zip>

## writeup

The challenge is a [Python script](Algorithm1-577265e1.py) in
the downloadable [ZIP file](Algorithm1-577265e1.zip). The Python
script takes a bytearray string defined in variable `plain` and
encrypts it using variable `key` (and some constants) with a
somewhat complicated algorithm, and then encodes the result
with a simple (easily invertible) function.
Maybe the encryption part is not bijective
(so we should call it rather a hash), but this is not important
regarding to the solution.

The script contains a `plain`, encrypts and encodes it, but
the `key` is missing. There are two comments which probably
mean encrypted and encoded strings:
```python
# out>>
# OO|OO||OO|||||OO|OO||O||O|O||O|||O|OOOOOOO|O|O|O|||||OO|||O|||OO||O|OOOOOO|O|OO|OO||||OO|||OOOO|||||O||||O|OO|O|O|O||OO|O||O|OO|O||O|||O||O|OO|OOOOOO||OOO|O|O|O|||O|OO|O|O||O||O||OOOOO|||OO|O|

# flag >>
# OO||O||O|O|||OOOO||||||O|O|||OOO||O|OOOO||O|O|OO|||||OOOO||||O||OO|OO||O||O|O|O|||||OOOOOO|O|O||OOOOOOO||O|||OOOO||OO|OO|||O|OO|O|||O|O|OO|OOOO|OOO|OOO|OOOO||O|OO||||OO||||OOO|O|O||OO||||O||OOO|||O|OO|OO||OO||OOOO|O|
```
Assuming the string `out` is the encrypted and encoded version
of `plain` defined in the script, the missing `key` can be guessed.
And assuming the string `flag` is the encrypted and encoded
version of the flag, using the guessed `key`, the plaintext
can be guessed.

Note, that in the encryption algorithm the byte at position `i`
of the encrypted text depends only on the byte at position `i%8`
of the key (the key is 8 bytes long):
```python
t2[i] ^= key[i % 8]
```
This results that brute-forcing the encryption byte-by-byte
should work. And brute-forcing byte-by-byte is very fast.

So the method to crack the algorithm and find the flag is:
1. Brute-force the `key` using the known `plain` and `out`,
2. Brute-force the flag using the guessed `key` and the known cipher.

To make it work, the encoding function should be inverted.
The encoding function is just a conversion to binary form:
```python
def encode(p):
    ret = ""
    for i in range(8):
        ret = ('|' if (p >> i) & 1 else 'O') + ret
    return ret
```
The inverse for a byte and for a sequence of encoded bytes:
```python
def decode(c):
    return int(c.replace('|', '1').replace('O','0'), 2)

def decode2(out):
    return [decode(c) for c in [out[i:i+8] for i in range(0, len(out), 8)]]
```
And the encryption algorithm should be moved to a
function `encrypt(plain, key)` (trivially), to make it
callable by the brute-forcer with several different parameters.

The whole crack is implemented in the modified version
of the challenge script:
[alg1-brute.py](alg1-brute.py)
The script assumes that both the key and the plaintext of the
flag contains printable chars. Moreover, the `out` ciphertext
is longer than the encrypted and encoded version of `plain`,
so there is only a prefix match, but it gives the correct
key to guess the flag.

The guessed key is:
```
^&#qD93_
```
and the flag is:
```
SSCTF{1qaz9ol.nhy64rfv7ujm}
```

There's a realtime [asciinema](https://asciinema.org)
screencast demonstrating the brute-force crack in action:
[![asciicast](https://asciinema.org/a/an9j56yrx6ry9cq898ps74wk0.png)](https://asciinema.org/a/an9j56yrx6ry9cq898ps74wk0)
